{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"index.html#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"index.html#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"dateien.html","title":"Lesen und Schreiben von Dateien","text":"<p>In diesem Abschnitt wird beschrieben, wie Sie mit Hilfe der Objekte StreamReader und StreamWriter Dateien lesen bzw. schreiben k\u00f6nnen.</p>"},{"location":"dateien.html#dateien-offnen-und-schlieen","title":"Dateien \u00f6ffnen und schlie\u00dfen","text":"<p>Um eine Datei zu lesen bzw. zu schreiben muss diese zuerst ge\u00f6ffnet werden.</p> <p>Ist eine Datei ge\u00f6ffnet, kann Sie (je nach Verwendungszweck) eventuell nicht von anderen Prozessen verwendet werden.</p> <p>Um die Datei f\u00fcr andere Prozesse wieder frei zu geben, muss der Stream bzw. die Datei wieder geschlossen werden:</p>"},{"location":"dateien.html#close","title":"Close()","text":"<pre><code>// StreamReader initialisieren (Datei \u00f6ffnen) (1)\nStreamReader sr = new StreamReader(\"TestDatei.txt\");\n\n// StreamReader wird in diesem Abschnitt verwendet\n\n// Datei freigeben (2)\nsr.Close();\n</code></pre> <ol> <li>Beim Erstellen des StreamReader bzw. StreamWriter-Objkets wird die Datei TestDatei.txt ge\u00f6ffnet.</li> <li>Close() schlie\u00dft die Datei und gibt sie somit wieder frei.</li> </ol>"},{"location":"dateien.html#using","title":"using","text":"<p>Da das Schlie\u00dfen der Datei oft vergessen wird, kann alternativ <code>using</code> verwendet werden:</p> <pre><code>// StreamReader initialisieren (1)\nusing (StreamReader sr = new StreamReader(\"TestDatei.txt\"))\n{\n    // StreamReader wird in diesem Codeblock verwendet\n} \n// Datei wird automatisch freigegeben (2)\n</code></pre> <ol> <li>Beim Erstellen des StreamReader bzw. StreamWriter-Objkets wird die Datei TestDatei.txt ge\u00f6ffnet.</li> <li>Beim Verlassen des Codeblocks wird der StreamReader automatisch geschlossen. Kein explizites aufrufen von Close() n\u00f6tig.</li> </ol>"},{"location":"dateien.html#streamreader-datei-lesen","title":"StreamReader (Datei lesen)","text":"<p>In der Regel werden Dateien zeilenweise mittels ReadLine() gelesen:</p> <pre><code>// StreamReader Initialisieren (1)\nusing (StreamReader sr = new StreamReader(\"TestDatei.txt\"))\n{ \n    // Erste Zeile einlesen (2)\n    string line = sr.ReadLine();\n    // Solange es etwas zu lesen gibt\n    while (line != null)\n    {\n        // Verarbeiten der Zeile (3)\n        Console.WriteLine(line);\n        // Einlesen der n\u00e4chsten Zeile (4)\n        line = sr.ReadLine();\n    }\n} \n</code></pre> <ol> <li>Das <code>using</code>-Keyword stellt sicher, dass der StreamReader wieder geschlossen wird</li> <li>Hier wird line mit der ersten Zeile von TestDatei.txt initialisiert</li> <li>Das \"Verarbeiten\" ist hier eine einfach Konsolenausgabe. Nat\u00fcrlich kann hier alles erdenkliche mit der Zeile passieren.</li> <li>Hier wird die n\u00e4chste Zeile eingelesen. Dieser Schritt ist in der Regel immer der letzte Schritt in der Schleife, da danach wieder gepr\u00fcft werden muss, ob es noch etwas einzulesen gibt.</li> </ol>"},{"location":"dateien.html#methoden","title":"Methoden","text":"Methode Erkl\u00e4rung Close() Closes the StreamReader object and the underlying stream, and releases any system resources associated with the reader. Peek() Returns the next available character but does not consume it. Calling this method multiple times will always return the same character (as Opposed to Read()). Read() Reads the next character from the input stream and advances the character position by one character. Read(Char[], Int32, Int32) Reads a specified maximum of characters from the current stream into a buffer, beginning at the specified index. ReadLine() Reads a line of characters from the current stream and returns the data as a string."},{"location":"dateien.html#streamwriter-datei-schreiben","title":"StreamWriter (Datei schreiben)","text":"<p>In der Regel werden Dateien zeilenweise mittels WriteLine() geschrieben:</p> <pre><code>// StreamWriter Initialisieren (1)\nusing (StreamWriter sw = new StreamWriter(\"TestDatei.txt\"))\n{\n    // Schreibe erste Zeile in TestDatei.txt\n    sw.WriteLine(\"Hello World!!\");\n    // Schreibe zweite Zeile in TestDatei.txt\n    sw.WriteLine(\"From the StreamWriter class\");\n} \n</code></pre> <ol> <li><code>using</code> stellt sicher, dass die Datei wieder freigegeben wird.</li> </ol>"},{"location":"dateien.html#methoden_1","title":"Methoden","text":"Methode Erkl\u00e4rung Close() Closes the current StreamWriter object and the underlying stream. Write(String) Writes a string to the stream. WriteLine() Writes a line terminator to the text stream."},{"location":"dateien.html#beispiel","title":"Beispiel","text":"<p>In diesem Beispiel wird ein Text einer Datei in Gro\u00dfbuchstaben umgewandlet:</p> <pre><code>class Program\n{\n    static void main()\n    {\n        // Streams initialisieren (1)\n        using (StreamReader sr = new StreamReader(\"kleinBuchstaben.txt))\n        using (StreamWriter sw = new StreamWriter(\"grossBuchstaben.txt\"))\n        {\n            // Erste Zeile lesen\n            string zeile = sr.ReadLine();\n            // Solange es etwas zu lesen gibt\n            while (zeile != null)\n            {\n                // Inhalt der Zeile gro\u00df schreiben\n                string zeileGross = zeile.ToUpper();\n                // Grossgeschriebene Zeile in Textdatei schreiben\n                sw.writeLine(zeileGross);\n                // N\u00e4chste Zeile lesen\n                zeile = sr.ReadLine();\n            }\n        }\n        // Streams werden automatisch geschlossen\n    }\n}\n</code></pre> <ol> <li>using kann auch hintereinander geschrieben werden, um mehrere Objekte zu verwalten.</li> </ol>"},{"location":"schleifen.html","title":"Wiederholung von Vorg\u00e4ngen durch Schleifen","text":"<p>Die <code>while</code>-Anweisung pr\u00fcft eine Bedingung und f\u00fchrt die Anweisung oder den Anweisungsblock nach <code>while</code> aus. Damit wird die Bedingung wiederholt \u00fcberpr\u00fcft und die Ausf\u00fchrung dieser Anweisungen wiederholt, bis die Bedingung \"false\" lautet. <pre><code>while(BEDINGUNG == true)\n{\n  // Codeblock wird solange ausgef\u00fchrt, bis BEDINGUNG nicht mehr TRUE\n}\n</code></pre></p> <p>Wichtig!</p> <p>Stellen Sie sicher, dass die Schleifenbedingung <code>while</code> zu \"false\" wechselt, nachdem Sie den Code ausgef\u00fchrt haben. Andernfalls erstellen Sie eine Endlosschleife, durch die das Programm niemals beendet wird.</p>"},{"location":"schleifen.html#while","title":"while","text":"<pre><code>int counter = 0;\nwhile (counter &lt; 5)\n{\n    Console.WriteLine($\"Hello World! The counter is {counter}\");\n    counter++;\n}\n</code></pre> Output <pre><code>Hello World! The counter is 0\nHello World! The counter is 1\nHello World! The counter is 2\nHello World! The counter is 3\nHello World! The counter is 4\n</code></pre>"},{"location":"schleifen.html#dowhile","title":"do...while","text":"<p>Die <code>do...while</code>-Schleife f\u00fchrt den Code zuerst aus und \u00fcberpr\u00fcft anschlie\u00dfend die Bedingung. Die <code>do...while</code>-Schleife wird im folgenden Code gezeigt: <pre><code>int counter = 0;\ndo\n{\n    Console.WriteLine($\"Hello World! The counter is {counter}\");\n    counter++;\n} while (counter &lt; 5);\n</code></pre></p> Output <pre><code>Hello World! The counter is 0\nHello World! The counter is 1\nHello World! The counter is 2\nHello World! The counter is 3\nHello World! The counter is 4\n</code></pre>"},{"location":"schleifen.html#for-schleife","title":"for-Schleife","text":"<p>Da die Operationen INITIALISIERUNG, Pr\u00fcfung der BEDINGUNG und die WERTVER\u00c4NDERUNG sehr oft in einer Schleife ben\u00f6tigt werden, wird hierf\u00fcr oft die <code>for-Schleife</code> verwendet. Diese ist \u00fcbersichtlicher, da die drei Operationen direkt an einem Ort stehen: <pre><code>for (INITIALISIERUNG; BEDINGUNG; WERTVER\u00c4NDERUNG) \n{\n    // auszuf\u00fchrender Quellcode\n}\n</code></pre></p> <p>Jede <code>for</code>-Schleife l\u00e4sst sich in eine <code>while</code>-Schleife \u00fcbersetzen: <pre><code>INITIALISIERUNG;\n\nwhile(BEDINGUNG) \n{\n    // auszuf\u00fchrender Quellcode\n    WERTVER\u00c4NDERUNG // (immer die letzte Anweisung)\n}\n</code></pre></p>"},{"location":"schleifen.html#beispiele","title":"Beispiele","text":""},{"location":"schleifen.html#counter","title":"counter","text":"<pre><code>for (int counter = 0; counter &lt; 5; counter++) \n{\n    Console.WriteLine($\"Hello World! The counter is {counter}\");\n}\n</code></pre> Output <pre><code>Hello World! The counter is 0\nHello World! The counter is 1\nHello World! The counter is 2\nHello World! The counter is 3\nHello World! The counter is 4\n</code></pre>"},{"location":"schleifen.html#array","title":"Array","text":"<pre><code>string[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\nfor(int i = 0; i &lt; cars.Length; i++) \n{\n  Console.WriteLine(cars[i]);\n}\n</code></pre> Output <pre><code>Volvo\nBMW\nFord\nMazda\n</code></pre> <p>Diese Schleife ist equivalent zum Array-Beispiel der foreach-Schleife.</p> <p>Dieses Beispiel hat das gleiche Verhalten wie die while-Schleife, jedoch sind die Initialisierung, Bedingung und Wert\u00e4nderung an einer Stelle. Der Vorteil zeigt sich vor allem bei l\u00e4ngeren Codebl\u00f6cken, bei denen bei der <code>while</code>-Schleife erst am Ende des Blocks die Wert\u00e4nderung stattfinden w\u00fcrde.</p>"},{"location":"schleifen.html#foreach-schleife","title":"<code>foreach</code>-Schleife","text":"<p>Beim Iterieren von Listen und Arrays wird der Index der <code>for</code>-Schleife oft nur gef\u00fchrt, um auf ein Element zuzugreifen.</p> <p>Eine indexlose Alternative bietet die <code>foreach</code>-Schleife:</p> <pre><code>foreach(type variableName in arrayName) \n{\n    // auszuf\u00fchrender Quellcode\n}\n</code></pre> <p>In der <code>foreach</code>-Schleife wird <code>variableName</code> in jedem Durchgang mit dem n\u00e4chsten Array- bzw. Listenelement belegt.</p>"},{"location":"schleifen.html#beispiele_1","title":"Beispiele","text":""},{"location":"schleifen.html#array_1","title":"Array","text":"<pre><code>string[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\nforeach (string car in cars) \n{\n  Console.WriteLine(car);\n}\n</code></pre> Output <pre><code>Volvo\nBMW\nFord\nMazda\n</code></pre> <p>Diese Schleife ist equivalent zum Array-Beispiel der for-Schleife.</p>"},{"location":"schleifen.html#liste","title":"Liste","text":"<pre><code>List&lt;string&gt; cars = new List&lt;string&gt;;\ncars.Add(\"Volvo\");\ncars.Add(\"BMW\");\ncars.Add(\"Ford\");\ncars.Add(\"Mazda\");\n\nforeach (string car in cars) \n{\n  Console.WriteLine(car);\n}\n</code></pre> Output <pre><code>Volvo\nBMW\nFord\nMazda\n</code></pre>"},{"location":"string.html","title":"String","text":""},{"location":"string.html#initialisieren","title":"Initialisieren","text":"<pre><code>// Declare without initializing.\nstring message1;\n// Initialize with string\nstring message2 = \"World\";\n// Set string content\nmessage1 = \"Hello\";\n\n// String concatination\nmessage3 = message1 + \" \" + message2 + \"!\";\n\n// Yields the same output\nConsole.WriteLine($\"{message1} {message2}!\");\nConsole.WriteLine(message3);\n</code></pre> Output <pre><code>Hello World!\nHello World!\n</code></pre>"},{"location":"string.html#contains-zeichenfolge-finden","title":"Contains (Zeichenfolge finden)","text":"<p>Die Methode Contains() findet eine beliebige Zeichenfolge in einem String. Sie gibt TRUE zur\u00fcck, wenn die Zeichenfolge gefunden wurde, andernfalls FALSE. <pre><code>string s1 = \"The quick brown fox jumps over the lazy dog\";\nstring s2 = \"fox\";\nbool b = s1.Contains(s2);\nif(b) {\n    Console.WriteLine(\"Found!);\n} else {\n    Console.WriteLine(\"Not found!\");\n}\n</code></pre></p> Output <pre><code>Found!\n</code></pre>"},{"location":"string.html#replace-zeichen-ersetzen","title":"Replace (Zeichen ersetzen)","text":"<p>Die Methode Replace() ersetzt die angegebenen Zeichen bzw. Zeichenfolgen im angegebenen String: <pre><code>string str = \"1 2 3 4 5 6 7 8 9\";\nConsole.WriteLine($\"Original string: \\\"{str}\\\"\");\nstring str2 = str.Replace(' ', ',');\nConsole.WriteLine($\"New string:      \\\"{str}\\\"\");\n</code></pre></p> Output <pre><code>Original string: \"1 2 3 4 5 6 7 8 9\"\nNew string:      \"1,2,3,4,5,6,7,8,9\"\n</code></pre>"},{"location":"string.html#split-string-teilen","title":"Split (String Teilen)","text":"<p>Mit Split() wird ein String am angegebenen Zeichen aufgeteilt. Sie gibt ein Array zur\u00fcck, das die Teile des Strings ohne das Trennzeichen enth\u00e4lt. Das Trennzeichen wird dabei entfernt.</p> ToUpper, ToLower<pre><code>string s = \"You win some. You lose some.\";\n\nstring[] subs = s.Split(' ');\n\nConsole.WriteLine($\"Substring: {subs[0]}\");\nConsole.WriteLine($\"Substring: {subs[4]}\");\nConsole.WriteLine($\"Substring: {subs[5]}\");\n</code></pre> Output <pre><code>Substring: You&lt;br&gt;\nSubstring: lose&lt;br&gt;\nSubstring: some.\n</code></pre>"},{"location":"string.html#toupper-tolower-gro-und-kleinbuchstaben","title":"ToUpper, ToLower (Gro\u00df- und Kleinbuchstaben)","text":"<p>Mit den Methoden ToUpper() und ToLower() wird ein String in Gro\u00df- bzw. Kleinbuchstaben umgewandelt:</p> ToUpper, ToLower<pre><code>string karen = \"i wAnT tO sPEak wiTh yOuR mAnaGer\";\n\nstring upperKaren = karen.ToUpper();\nstring lowerKaren = karen.ToLower();\n\nConsole.WriteLine($\"Uppercase: {upperKaren}\");\nConsole.WriteLine($\"Lowercase: {lowerKaren}\");\n</code></pre> Output <pre><code>Uppercase: I WANT TO SPEAK WITH YOUR MANAGER\nLowercase: i want to speak with your manager\n</code></pre>"},{"location":"string.html#trim-uberflussige-leerzeichen-entfernen","title":"Trim (\u00dcberfl\u00fcssige Leerzeichen entfernen)","text":"<p>Mit Trim() werden Leerzeichen am Anfang bzw. am Ende entfernt. TrimStart() entfernt Leerzeichen vor dem ersten Zeichen, TrimEnd() entfernt Leerzeichen am Ende. Trim() entfernt die Leerzeichen am Anfang und am Ende.</p> Trim()<pre><code>string whiteSpace = \"    Teststring    \";\n\nstring trimStart = whiteSpace.TrimStart();\nstring trimEnd = whiteSpace.TrimEnd();\nstring trim = whiteSpace.Trim();\n\nConsole.WriteLine($\"TrimStart: \\\"{trimStart}\\\"\");\nConsole.WriteLine($\"TrimEnd: \\\"{trimEnd}\\\"\");\nConsole.WriteLine($\"Trim: \\\"{trim}\\\"\");\n</code></pre> Output <pre><code>TrimStart: \"Teststring    \"\nTrimEnd: \"    Teststring\"\nTrim: \"Teststring\"\n</code></pre>"},{"location":"db/index.html","title":"Datenbankanbindung in C#","text":"<p>In der modernen Softwareentwicklung spielt die Datenbankanbindung eine zentrale Rolle, besonders wenn es um die Entwicklung von Anwendungen geht, die auf dynamischen, persistenten Datenstrukturen basieren. C# als eine der f\u00fchrenden Programmiersprachen im .NET-Framework von Microsoft bietet robuste L\u00f6sungen f\u00fcr die Datenbankintegration. Eine der g\u00e4ngigen Methoden, um eine solche Integration zu realisieren, ist die Verwendung des <code>MySql.Data</code>-Pakets. Dieses Paket erm\u00f6glicht es Entwicklern, C#-Anwendungen nahtlos mit MySQL-Datenbanken zu verbinden, indem es eine direkte Schnittstelle zu MySQL bietet. Die Notwendigkeit einer Datenbankanbindung in C# ergibt sich aus dem Bedarf, Daten effizient zu speichern, abzurufen und zu manipulieren. Egal ob es um die Verwaltung von Benutzerdaten, die Durchf\u00fchrung von Transaktionen oder das Reporting geht, eine zuverl\u00e4ssige Datenbankverbindung ist essentiell, um die Integrit\u00e4t und Leistungsf\u00e4higkeit der Anwendung zu gew\u00e4hrleisten. In dieser Anleitung werden wir uns darauf konzentrieren, wie man mithilfe des <code>MySql.Data</code>-Pakets eine solche Anbindung realisiert, um eine solide Grundlage f\u00fcr die Entwicklung datenbankgest\u00fctzter C#-Anwendungen zu schaffen.</p>"},{"location":"db/beispiel.html","title":"Beispiel","text":"<p>Hier ist ein vollst\u00e4ndiges C#-Beispiel, das den Aufbau einer Verbindung zu einer MySQL-Datenbank, das Schreiben von Daten in eine Tabelle und das anschlie\u00dfende Lesen dieser Daten demonstriert. Dieses Beispiel setzt voraus, dass Sie bereits das <code>MySql.Data</code>-Paket installiert haben und eine Tabelle namens <code>person</code> in Ihrer Datenbank existiert, die Felder wie <code>id</code>, <code>Vorname</code>, <code>Nachname</code>, <code>GebDatum</code> und <code>Gehalt</code> enth\u00e4lt.</p> <pre><code>using System;\nusing MySql.Data.MySqlClient;\n\nnamespace MySQLConnectionExample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string connectionString = \"Server=bszw.ddns.net;Database=xxx;Uid=yyy;Pwd=zzz;\";\n\n            using (MySqlConnection con = new MySqlConnection(connectionString))\n            {\n                try\n                {\n                    // Schreiben von Daten in die Datenbank\n                    string insertQuery = @$\"INSERT INTO person ({p.Id}, {p.Vorname}, {p.Nachname}, {p.GebDatum}, {p.Gehalt}) \n                       VALUES (id, Vorname, Nachname, GebDatum, Gehalt)\";\n\n                    using (MySqlCommand cmd = new MySqlCommand(insertQuery, con))\n                    {\n                        cmd.ExecuteNonQuery();\n                        Console.WriteLine(\"Datensatz erfolgreich hinzugef\u00fcgt.\");\n                    }\n\n                    // Lesen von Daten aus der Datenbank\n                    string selectQuery = \"SELECT * FROM person\";\n                    using (MySqlCommand cmd = new MySqlCommand(selectQuery, con))\n                    using (MySqlDataReader rdr = cmd.ExecuteReader())\n                    {\n                        while (rdr.Read())\n                        {\n                            int id = rdr.GetInt32(\"id\");\n                            string vorname = rdr.GetString(\"Vorname\");\n                            string nachname = rdr.GetString(\"Nachname\");\n                            DateTime gebDatum = rdr.GetDateTime(\"GebDatum\");\n                            double gehalt = rdr.GetDouble(\"Gehalt\");\n\n                            Console.WriteLine($\"{id} {nachname} {vorname} {gebDatum.ToShortDateString()} {gehalt}\");\n                        }\n                    }\n                }\n                catch (MySqlException e)\n                {\n                    Console.WriteLine($\"Fehler: {e.Message}\");\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Dieses Beispiel umfasst:</p> <ol> <li>Verbindungsaufbau: Zu Beginn wird eine Verbindung zur MySQL-Datenbank hergestellt.</li> <li>Schreiben von Daten: Es werden Daten in die <code>person</code>-Tabelle eingef\u00fcgt. Beachten Sie die Verwendung von Parametern im SQL-Befehl zur Vermeidung von SQL-Injection.</li> <li>Lesen von Daten: Anschlie\u00dfend werden die Daten mit einem SELECT-Befehl abgerufen und ausgegeben.</li> <li>Verbindungsmanagement: Die Verwendung des <code>using</code>-Statements sorgt daf\u00fcr, dass die Verbindung und andere Ressourcen korrekt freigegeben werden, unabh\u00e4ngig davon, ob der Vorgang erfolgreich war oder ein Fehler aufgetreten ist.</li> </ol> <p>Stellen Sie sicher, dass Sie die Verbindungszeichenfolge entsprechend Ihrer Datenbankkonfiguration anpassen und die richtigen Werte f\u00fcr Server, Datenbank, Benutzer-ID und Passwort verwenden.</p>"},{"location":"db/datanbankanbindung.html","title":"Installation des MySql.Data-Pakets \u00fcber den NuGet Package Manager","text":"<p>Die Integration von MySQL-Datenbanken in C#-Anwendungen erfordert das <code>MySql.Data</code>-Paket, das einfach \u00fcber den NuGet Package Manager in Visual Studio installiert werden kann. Der NuGet Package Manager ist ein essentielles Tool in Visual Studio, das die Verwaltung von Paketen in Ihren Projekten vereinfacht. Um das MySql.Data-Paket zu installieren, folgen Sie diesen Schritten:</p> <ol> <li> <p>\u00d6ffnen des NuGet Package Managers: Starten Sie Visual Studio und \u00f6ffnen Sie Ihre L\u00f6sung (Solution). Navigieren Sie im Hauptmen\u00fc zu <code>Tools</code> &gt; <code>NuGet Package Manager</code> &gt; <code>Manage NuGet Packages for Solution...</code>. Dies \u00f6ffnet den NuGet Package Manager f\u00fcr Ihre L\u00f6sung.</p> </li> <li> <p>Suchen des <code>MySql.Data-Pakets</code>: Im NuGet Package Manager, wechseln Sie zum Browse-Tab. Geben Sie in das Suchfeld \u201eMySql\u201c ein. Die Suche liefert verschiedene Pakete, einschlie\u00dflich <code>MySql.Data</code>.</p> </li> <li> <p>Auswahl und Installation: Klicken Sie auf das <code>MySql.Data</code>-Paket in den Suchergebnissen. Auf der linken Seite werden die Projekte (Solutions) angezeigt, zu denen Sie das Paket hinzuf\u00fcgen k\u00f6nnen. Setzen Sie einen Haken bei der Solution, in der Sie das Paket verwenden m\u00f6chten, und klicken Sie auf Install. Visual Studio wird nun das Paket herunterladen und installieren. Dieser Vorgang kann einige Momente in Anspruch nehmen.</p> </li> <li> <p>Verwendung im Code: Nach der erfolgreichen Installation k\u00f6nnen Sie das MySql.Data-Paket in Ihrem C#-Projekt verwenden. Dazu m\u00fcssen Sie nur die entsprechenden using-Direktiven zu Ihren C#-Dateien hinzuf\u00fcgen, um auf die Funktionalit\u00e4ten des Pakets zugreifen zu k\u00f6nnen.</p> </li> </ol> <p>Durch die Installation des <code>MySql.Data</code>-Pakets \u00fcber den NuGet Package Manager stellen Sie sicher, dass Ihr Projekt alle notwendigen Abh\u00e4ngigkeiten besitzt, um eine Verbindung zu MySQL-Datenbanken herzustellen und zu verwalten. Dies ist der erste Schritt, um die Kraft von MySQL in Ihren C#-Anwendungen zu nutzen.</p> <p>Nach der Installation sollte das Paket im Reiter <code>Installed</code> angezeigt werden:</p> <p></p> <p>Jetzt kann das Paket mittels using-Direktive am Anfang des Codes verwendet werden:</p> <pre><code>using MySql.Data.MySqlClient;\n</code></pre>"},{"location":"db/daten-lesen.html","title":"Lesen von Daten aus der Datenbank","text":"<p>Nachdem eine Verbindung zur MySQL-Datenbank erfolgreich hergestellt wurde, ist der n\u00e4chste Schritt oft das Lesen von Daten. Dies kann durch Ausf\u00fchren eines SQL-Befehls mit einem <code>MySqlCommand</code>-Objekt und dem Abrufen der Ergebnisse durch einen <code>MySqlDataReader</code> erfolgen. Hier ist ein einfaches Beispiel, das zeigt, wie Daten aus einer Tabelle namens <code>person</code> gelesen werden k\u00f6nnen:</p> <pre><code>MySqlCommand cmd = new MySqlCommand(\"SELECT * FROM person\", con);\nMySqlDataReader rdr = cmd.ExecuteReader();\n\nwhile (rdr.Read())\n{\n    int id = rdr.GetInt32(\"Id\");\n    string vn = rdr.GetString(\"Vorname\");\n    string nn = rdr.GetString(\"Nachname\");\n    DateTime datum = rdr.GetDateTime(\"GebDatum\");\n    double gehalt = rdr.GetDouble(\"Gehalt\");\n\n    Console.WriteLine($\"{id} {nn} {vn} {datum.ToShortDateString()} {gehalt}\");\n}\n\nrdr.Close();\n</code></pre> <p>In diesem Beispiel f\u00fchrt <code>cmd.ExecuteReader()</code> den SQL-Befehl <code>SELECT * FROM person</code> aus und gibt einen <code>MySqlDataReader</code> (<code>rdr</code>) zur\u00fcck, der die Daten enth\u00e4lt. Die <code>while</code>-Schleife mit <code>rdr.Read()</code> iteriert \u00fcber alle Datens\u00e4tze im Ergebnis. Innerhalb der Schleife k\u00f6nnen Sie auf die einzelnen Spaltenwerte des aktuellen Datensatzes zugreifen, indem Sie die entsprechenden <code>Get...</code>-Methoden des <code>MySqlDataReader</code> verwenden, z.B. <code>GetInt32</code> f\u00fcr Integer, <code>GetString</code> f\u00fcr String-Werte, <code>GetDateTime</code> f\u00fcr Datumswerte und <code>GetDouble</code> f\u00fcr Gleitkommazahlen. Diese Werte werden dann in der Konsole ausgegeben.</p> <p>Es ist wichtig, den <code>MySqlDataReader</code> nach Gebrauch mit <code>rdr.Close()</code> zu schlie\u00dfen, um Ressourcen freizugeben. Alternativ k\u00f6nnen Sie auch das <code>using</code>-Statement verwenden, das den <code>MySqlDataReader</code> automatisch schlie\u00dft, sobald der Block abgeschlossen ist:</p> <pre><code>using (MySqlCommand cmd = new MySqlCommand(\"SELECT * FROM person\", con))\nusing (MySqlDataReader rdr = cmd.ExecuteReader())\n{\n    while (rdr.Read())\n    {\n        // Verarbeiten der Daten wie oben\n    }\n}\n</code></pre> <p>Dieser Ansatz stellt sicher, dass alle Ressourcen ordnungsgem\u00e4\u00df bereinigt werden und ist besonders n\u00fctzlich in Szenarien, wo mehrere Datenbankoperationen durchgef\u00fchrt werden und die \u00dcbersichtlichkeit des Codes gewahrt bleiben soll.</p>"},{"location":"db/daten-schreiben.html","title":"Schreiben von Daten in die Datenbank","text":"<p>Das Einf\u00fcgen neuer Daten in eine MySQL-Datenbank ist ein grundlegender Bestandteil der Interaktion mit relationalen Datenbanken. In C# kann dies effizient mit einem <code>MySqlCommand</code>-Objekt erreicht werden, das einen SQL-Insert-Befehl ausf\u00fchrt. Hier ist ein Beispiel, wie Sie Daten in die Tabelle <code>person</code> schreiben k\u00f6nnen, die Felder wie <code>id</code>, <code>Vorname</code>, <code>Nachname</code>, <code>GebDatum</code> und <code>Gehalt</code> enth\u00e4lt:</p> <pre><code>// Anlegen einer Beispielperson\nPerson p = new Person(...);\n\n// Hier wird der SQL-Befehl zusammengesetzt\nstring insertQuery = @$\"INSERT INTO person ({p.Id}, {p.Vorname}, {p.Nachname}, {p.GebDatum}, {p.Gehalt}) \n                       VALUES (id, Vorname, Nachname, GebDatum, Gehalt)\";\n\n// Zuerst den Command erstellen\nusing (MySqlCommand cmd = new MySqlCommand(insertQuery, con))\n{\n    // F\u00fchrt den Insert-Befehl aus\n    cmd.ExecuteNonQuery(); \n}\n</code></pre> <p>In diesem Beispiel wird der SQL-Insert-Befehl als String mit Werten vorbereitet.</p> <p>Das Ausf\u00fchren des Befehls erfolgt durch Aufrufen von <code>cmd.ExecuteNonQuery()</code>. Diese Methode ist ideal f\u00fcr SQL-Statements, die keine Daten zur\u00fcckgeben, wie INSERT, UPDATE oder DELETE. Vor dem Ausf\u00fchren des Insert-Befehls sollte sichergestellt werden, dass die Datenbankverbindung ge\u00f6ffnet ist (<code>con.Open()</code>).</p>"},{"location":"db/verbindung.html","title":"Herstellung der Verbindung zur Datenbank","text":"<p>Nach der Installation des <code>MySql.Data</code>-Pakets ist der n\u00e4chste Schritt die Herstellung einer Verbindung zu Ihrer MySQL-Datenbank. Die Verbindung wird \u00fcber einen Verbindungsstring definiert und mit Hilfe eines <code>MySqlConnection</code>-Objekts verwaltet. Hier ist ein grundlegendes Beispiel, wie Sie eine solche Verbindung aufbauen k\u00f6nnen:</p> <pre><code>string constr = \"Server=bszw.ddns.net;Database=xxx;Uid=yyy;Pwd=zzz;\";\nMySqlConnection con = new MySqlConnection(constr);\ncon.Open();\n</code></pre> <p>In diesem Beispiel ist <code>constr</code> der Verbindungsstring, der die notwendigen Informationen f\u00fcr die Verbindung zur Datenbank enth\u00e4lt: den Servernamen (<code>Server</code>), den Datenbanknamen (<code>Database</code>), den Benutzernamen (<code>Uid</code>) und das Passwort (<code>Pwd</code>). Diese Informationen sollten entsprechend Ihrer Datenbankkonfiguration angepasst werden.</p> <p>Es ist entscheidend, dass die Datenbankverbindung ordnungsgem\u00e4\u00df verwaltet wird, insbesondere im Fehlerfall. Eine nicht geschlossene Verbindung kann zu Speicherlecks und anderen Problemen f\u00fchren. Es gibt zwei g\u00e4ngige Muster, um sicherzustellen, dass die Verbindung immer ordnungsgem\u00e4\u00df geschlossen wird: <code>try-catch-finally</code> und <code>using</code>.</p>"},{"location":"db/verbindung.html#verwendung-von-try-catch-finally","title":"Verwendung von <code>try-catch-finally</code>","text":"<p>Das <code>try-catch-finally</code>-Muster erm\u00f6glicht es Ihnen, die Verbindung in einem gesch\u00fctzten Block zu \u00f6ffnen und sicherzustellen, dass die Verbindung im <code>finally</code>-Block geschlossen wird, unabh\u00e4ngig davon, ob ein Fehler auftritt oder nicht:</p> <pre><code>try\n{\n    con.Open();\n    // Datenbankoperationen hier\n}\ncatch (MySqlException e)\n{\n    // Fehlerbehandlung hier\n}\nfinally\n{\n    con.Close();\n}\n</code></pre>"},{"location":"db/verbindung.html#verwendung-von-using","title":"Verwendung von <code>using</code>","text":"<p>Das <code>using</code>-Statement bietet eine saubere und effiziente Methode, um Ressourcen automatisch freizugeben, sobald der Block abgeschlossen ist. Im Fall von <code>MySqlConnection</code> wird die Verbindung automatisch geschlossen, wenn der <code>using</code>-Block verlassen wird:</p> <pre><code>using (MySqlConnection con = new MySqlConnection(constr))\n{\n    con.Open();\n    // Datenbankoperationen hier\n}\n</code></pre> <p>Beide Methoden sind effektiv, um sicherzustellen, dass die Datenbankverbindung ordnungsgem\u00e4\u00df geschlossen wird. Die Wahl zwischen <code>try-catch-finally</code> und <code>using</code> h\u00e4ngt von Ihren spezifischen Anforderungen und dem Kontext Ihres Codes ab. Im Allgemeinen bietet das <code>using</code>-Statement eine k\u00fcrzere und klarere Syntax, w\u00e4hrend <code>try-catch-finally</code> mehr Flexibilit\u00e4t bei der Fehlerbehandlung bietet.</p>"},{"location":"reflection/index.html","title":"Einleitung zu Reflection in C","text":"<p>Reflection in C# ist ein m\u00e4chtiges Feature, das Entwicklern die M\u00f6glichkeit gibt, zur Laufzeit Informationen \u00fcber Assemblies, Module und Typen zu ermitteln und zu manipulieren. Dies umfasst die F\u00e4higkeit, Details \u00fcber Klassen, Attribute, Eigenschaften (Properties) und Methoden eines Programms zu entdecken, ohne im Vorfeld deren Namen oder Typen zu kennen. Mit Reflection k\u00f6nnen Entwickler dynamisch Instanzen von Klassen erstellen, Methoden aufrufen und auf Eigenschaften zugreifen, was f\u00fcr eine Vielzahl von Anwendungen n\u00fctzlich ist, einschlie\u00dflich der Entwicklung von Frameworks, Debugging-Tools und dynamischen Benutzeroberfl\u00e4chen.</p> <p>Reflection bietet eine introspektive F\u00e4higkeit in C#, die es erlaubt, den Typ eines Objekts zu untersuchen, auf dessen Metadaten zuzugreifen und diese Informationen zu nutzen, um Entscheidungen zur Laufzeit zu treffen. Dies bedeutet, dass Entwickler nicht nur herausfinden k\u00f6nnen, welche Klassen, Methoden oder Attribute vorhanden sind, sondern auch deren Signaturen, Zugriffsmodifikatoren, benutzerdefinierte Attribute und viele andere Details untersuchen k\u00f6nnen. </p> <p>Die Verwendung von Reflection kann jedoch auch Nachteile haben, wie z.B. Leistungseinbu\u00dfen, da der Zugriff auf Typinformationen zur Laufzeit mehr Ressourcen erfordert als der direkte Zugriff zur Kompilierungszeit. Zudem erfordert die Nutzung von Reflection ein tiefes Verst\u00e4ndnis der Struktur des Zielprogramms, was die Komplexit\u00e4t erh\u00f6hen kann. Trotz dieser Herausforderungen bleibt Reflection ein unverzichtbares Werkzeug in der Toolbox eines C#-Entwicklers, das f\u00fcr spezielle Anwendungsf\u00e4lle, wo Flexibilit\u00e4t und dynamische Typisierung erforderlich sind, von unsch\u00e4tzbarem Wert ist.</p> <p>Diese Dokumentation f\u00fchrt Sie durch die Grundlagen der Reflection in C#, einschlie\u00dflich der Untersuchung von Typen, dem Zugriff auf Attribute, Properties und Methoden sowie deren Anwendung in realen Szenarien.</p>"},{"location":"reflection/datentyp-ermitteln.html","title":"Datentyp dynamisch zur Laufzeit ermitteln","text":""},{"location":"reflection/datentyp-ermitteln.html#type-objekt","title":"Type-Objekt","text":"<p>Um den Typ eines Objekts zur Laufzeit zu ermitteln, k\u00f6nnen verschiedene Methoden verwendet werden. Diese Methoden geben ein <code>Type</code>-Objekt zur\u00fcck, das alle relevanten Metainformationen \u00fcber die Klasse bzw. das Objekt enth\u00e4lt.</p> <ul> <li><code>m.GetType()</code>: Ermittelt den Typ einer Instanz <code>m</code>.</li> <li><code>typeof(Mitarbeiter)</code>: Ermittelt den Typ der Klasse <code>Mitarbeiter</code>.</li> <li><code>Type.GetType(\"Mitarbeiter\")</code>: Ermittelt den Typ basierend auf dem qualifizierten Namen der Klasse.</li> </ul> <p>Warning</p> <p>Im ersten Schritt muss immer das Typen-Objekt erstellt werden. Dieses Objekt bildet die Grundlage zur Ermittlung der Ermittlung der Metadaten.</p>"},{"location":"reflection/datentyp-ermitteln.html#typ-eines-objekts-ermitteln","title":"Typ eines Objekts ermitteln","text":"<p>Nachdem wir die Klasse <code>Mitarbeiter</code> definiert haben, verwenden wir die Reflection-Methoden, um Metainformationen zur Laufzeit zu extrahieren.</p> <pre><code>Mitarbeiter mitarbeiter = new Mitarbeiter(\"Max\", \"Mustermann\", 50000, \"Berlin\");\n\n// Typinformationen ermitteln\nType type = mitarbeiter.GetType();\n\nConsole.WriteLine(type.ToString());\n</code></pre> Output <pre><code>Mitarbeiter\n</code></pre>"},{"location":"reflection/datentyp-ermitteln.html#getfields","title":"<code>GetFields()</code>","text":"<p>Liefert die Attribute (Felder) der Klasse zur\u00fcck.</p> <pre><code>FieldInfo[] fields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);\nforeach (var field in fields)\n{\n    Console.WriteLine($\"{field.Name}: {field.FieldType}\");\n}\n</code></pre> Output <pre><code>_vorname: System.String\n_nachname: System.String\n_gehalt: System.Double\n_arbeitsort: System.String\n</code></pre> <p>Warning</p> <p>Beachte, dass private Felder nur mit entsprechenden <code>BindingFlags</code> sichtbar sind.</p>"},{"location":"reflection/datentyp-ermitteln.html#getproperties","title":"<code>GetProperties()</code>","text":"<p>Liefert die Properties (Eigenschaften) einer Klasse zur\u00fcck.</p> <pre><code>PropertyInfo[] properties = type.GetProperties();\nforeach (var property in properties)\n{\n    Console.WriteLine($\"{property.Name}: {property.PropertyType}\");\n}\n</code></pre> Output <pre><code>Vorname: System.String\nNachname: System.String\nGehalt: System.Double\nArbeitsort: System.String\n</code></pre>"},{"location":"reflection/datentyp-ermitteln.html#getmethods","title":"<code>GetMethods()</code>","text":"<p>Liefert die Methoden einer Klasse zur\u00fcck.</p> <pre><code>MethodInfo[] methods = type.GetMethods();\nforeach (var method in methods)\n{\n    Console.WriteLine($\"{method.Name}\");\n}\n</code></pre> Output <pre><code>AnzeigenInformationen\nErhoeheGehalt\nBerechneJahresgehalt\n</code></pre> <p>Info</p> <p>Diese Liste enth\u00e4lt auch geerbte Methoden von <code>Object</code>, wie <code>ToString</code>, <code>Equals</code> usw.</p>"},{"location":"reflection/datentyp-ermitteln.html#getconstructors","title":"<code>GetConstructors()</code>","text":"<p>Liefert die Konstruktoren einer Klasse zur\u00fcck</p> <pre><code>ConstructorInfo[] constructors = type.GetConstructors();\nforeach (var constructor in constructors)\n{\n    Console.WriteLine($\"Konstruktor: {constructor.ToString()}\");\n}\n</code></pre> Output <pre><code>Konstruktor: Void .ctor()\nKonstruktor: Void .ctor(System.String, System.String, System.Double, System.String)\n</code></pre>"},{"location":"reflection/datentyp-ermitteln.html#getparameters","title":"<code>GetParameters()</code>","text":"<p>Liefert die Paramter von Konstruktoren bzw. Methoden zur\u00fcck.</p> <pre><code>foreach (var constructor in constructors)\n{\n    ParameterInfo[] parameters = constructor.GetParameters();\n    foreach (var parameter in parameters)\n    {\n        Console.WriteLine($\"{parameter.Name}: {parameter.ParameterType}\");\n    }\n}\n</code></pre> Output <pre><code>vorname: System.String\nnachname: System.String\ngehalt: System.Double\narbeitsort: System.String\n</code></pre> <p>Tip</p> <p>Analog k\u00f6nnen die Parameter auch f\u00fcr Methoden ausgegeben werden!</p>"},{"location":"reflection/klasse-mitarbeiter.html","title":"Klasse Mitarbeiter","text":"<p>Dieses Kapitel verwendet die Beispielklasse <code>Mitarbeiter</code> mit privaten Attributen, die durch Properties zug\u00e4nglich gemacht werden, sowie mit Konstruktoren und Methoden, um die Nutzung von Reflection zu demonstrieren.</p> <pre><code>classDiagram\n    class Mitarbeiter {\n        - string _vorname\n        - string _nachname\n        - double _gehalt\n        - string _arbeitsort\n        \u00abproperty\u00bb + string Vorname\n        \u00abproperty\u00bb + string Nachname\n        \u00abproperty\u00bb + double Gehalt\n        \u00abproperty\u00bb + string Arbeitsort\n        + Mitarbeiter()\n        + Mitarbeiter(string vorname, string nachname, double gehalt, string arbeitsort)\n        + void AnzeigenInformationen()\n        + void ErhoeheGehalt(double betrag)\n        + double BerechneJahresgehalt()\n    }</code></pre>"},{"location":"reflection/objekte-erstellen.html","title":"Objekte zur Laufzeit erstellen","text":"<p>Ein zentraler Aspekt von Reflection in C# ist die F\u00e4higkeit, Objekte zur Laufzeit zu erstellen. Diese F\u00e4higkeit ist besonders n\u00fctzlich in Szenarien, in denen Typen dynamisch zur Laufzeit geladen oder instanziiert werden m\u00fcssen, ohne dass sie zur Kompilierungszeit bekannt sind. Ein h\u00e4ufig verwendetes Werkzeug daf\u00fcr ist die Klasse <code>Activator</code>, die Teil des .NET Frameworks ist.</p>"},{"location":"reflection/objekte-erstellen.html#verwendung-des-activators","title":"Verwendung des Activators","text":"<p>Die <code>Activator</code>-Klasse bietet mehrere Methoden, um Instanzen von Typen zur Laufzeit zu erstellen. Eine der gebr\u00e4uchlichsten Methoden ist <code>CreateInstance</code>. Diese Methode hat mehrere \u00dcberladungen, die es erm\u00f6glichen, Objekte auf verschiedene Arten zu instanziieren, unter anderem durch Angabe des Typs, der Parameter f\u00fcr den Konstruktor und sogar durch Angabe des Assemblynamens, in dem sich der Typ befindet.</p> <p>Um ein Objekt vom Typ <code>Mitarbeiter</code> zur Laufzeit zu erstellen, k\u00f6nnen wir folgenden Ansatz verfolgen:</p> <pre><code>// Erstellen eines Objekts vom Typ Mitarbeiter ohne Parameter (nutzt den Standardkonstruktor)\nMitarbeiter mitarbeiter1 = (Mitarbeiter)Activator.CreateInstance(typeof(Mitarbeiter));\n// Initialisierung der Attribute f\u00fcr mitarbeiter1\nmitarbeiter1.Vorname = \"Anna\";\nmitarbeiter1.Nachname = \"M\u00fcller\";\nmitarbeiter1.Gehalt = 40000.0;\nmitarbeiter1.Arbeitsort = \"Hamburg\";\n\n// Erstellen eines Objekts vom Typ Mitarbeiter mit Parametern f\u00fcr den Konstruktor\nobject[] parameters = { \"Max\", \"Mustermann\", 50000.0, \"Berlin\" };\nMitarbeiter mitarbeiter2 = (Mitarbeiter)Activator.CreateInstance(typeof(Mitarbeiter), parameters);\n\n// Ausgabe zur Demonstration\nmitarbeiter1.AnzeigenInformationen();\nmitarbeiter2.AnzeigenInformationen();\n</code></pre> Output <pre><code>Vorname: Anna, Nachname: M\u00fcller, Gehalt: 40000, Arbeitsort: Hamburg\nVorname: Max, Nachname: Mustermann, Gehalt: 50000, Arbeitsort: Berlin\n</code></pre>"},{"location":"reflection/objekte-erstellen.html#erklarung","title":"Erkl\u00e4rung","text":"<ul> <li> <p><code>Activator.CreateInstance(typeof(Mitarbeiter))</code>: Diese Zeile erstellt eine neue Instanz von <code>Mitarbeiter</code> unter Verwendung des Standardkonstruktors. Da <code>CreateInstance</code> ein Objekt vom Typ <code>object</code> zur\u00fcckgibt, ist ein explizites Casting auf den Typ <code>Mitarbeiter</code> notwendig.</p> </li> <li> <p><code>Activator.CreateInstance(typeof(Mitarbeiter), parameters)</code>: Hier wird eine neue Instanz von <code>Mitarbeiter</code> erstellt, wobei ein Array von Objekten als Parameter f\u00fcr den Konstruktor \u00fcbergeben wird. Diese Methode ist n\u00fctzlich, wenn der zu verwendende Konstruktor Parameter erwartet. Auch hier ist ein Casting erforderlich.</p> </li> </ul>"},{"location":"reflection/objekte-erstellen.html#vorteile-und-uberlegungen","title":"Vorteile und \u00dcberlegungen","text":"<p>Die Verwendung des <code>Activator</code> zum Erstellen von Objekten bietet eine flexible L\u00f6sung f\u00fcr die dynamische Instanziierung von Klassen zur Laufzeit. Dies kann in Situationen n\u00fctzlich sein, in denen der exakte Typ eines Objekts erst zur Laufzeit bekannt ist, beispielsweise beim Laden von Plugins oder bei der Implementierung von Fabrikmethoden in Designmustern.</p> <p>Es ist jedoch wichtig zu beachten, dass der Einsatz von Reflection und insbesondere des <code>Activator</code> zur Objekterstellung Overhead verursacht und die Performance beeintr\u00e4chtigen kann. Deshalb sollte der Einsatz wohl\u00fcberlegt und in Performance-kritischen Bereichen vermieden oder minimiert werden.</p>"}]}